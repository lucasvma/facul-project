{"ast":null,"code":"// import NextAuth from 'next-auth'\n// import Providers from 'next-auth/providers'\n// import url from \"url\";\n//\n// // let cachedDb: Db = null\n//\n// const connectToDatabase = async (uri) => {\n//     if (cachedDb) {\n//         return cachedDb\n//     }\n//\n//     const client = await MongoClient.connect(uri, {\n//         useNewUrlParser: true,\n//         useUnifiedTopology: true\n//     })\n//\n//     const dbName = url.parse(uri).pathname.substr(1)\n//\n//     const db = client.db(dbName)\n//\n//     // cachedDb = db\n//\n//     return db\n// };\n//\n// const options = {\n//     providers: [\n//         Providers.GitHub({\n//             clientId: process.env.GITHUB_ID,\n//             clientSecret: process.env.GITHUB_SECRET\n//         }),\n//         Providers.Credentials({\n//             name: 'Credentials',\n//             credentials: {\n//                 email: { label: 'email', type: 'email', placeholder: 'E-mail' },\n//                 password: { label: 'password', type: 'password' }\n//             },\n//             async authorize(credentails) {\n//                 const db = await connectToDatabase(process.env.MONGODB_URI);\n//\n//                 const collection = db.collection('users');\n//\n//                 const user = await collection.findOne({ email: credentails.email })\n//\n//                 if ((!user) || (!await bcrypt.compare(credentails.password, user.password))) {\n//                     return Promise.reject('/');\n//                 }\n//\n//                 user.password = undefined;\n//\n//                 return Promise.resolve(user)\n//             },\n//         })\n//     ],\n//     database: process.env.MONGODB_URI,\n//     session: {\n//         jwt: true\n//     },\n//     jwt: { },\n//     pages: {\n//         signIn: '/auth/signin',\n//         signOut: '/auth/signout',\n//         error: '/auth/error',\n//         verifyRequest: '/auth/verify-request',\n//         newUser: null\n//     },\n//     callbacks: {\n//         signIn: async (user, account, profile) => {\n//             const isAllowedToSignIn = true\n//\n//             if (isAllowedToSignIn) {\n//                 return Promise.resolve(true)\n//             }\n//\n//             return Promise.resolve(false)\n//         },\n//         redirect: async (url, baseUrl) => {\n//             return url.startsWith(baseUrl)\n//                 ? Promise.resolve(url)\n//                 : Promise.resolve(baseUrl)\n//         },\n//         session: async (session, user, sessionToken) => {\n//             session.foo = 'bar' // Add property to session\n//             return Promise.resolve(session)\n//         }\n//     },\n//     events: {\n//         signIn: async (user, account, profile) => {\n//             console.log('LogedIn')\n//             return Promise.resolve('/home')\n//         },\n//         signOut: async (message) => { console.log('console2', message) },\n//         createUser: async (message) => { console.log('console3', message) },\n//         redirect: async (url, baseUrl) => { return Promise.resolve(baseUrl) },\n//         session: async (session, user) => { return Promise.resolve(session) },\n//         error: async (message) => { console.log('console6', message)  }\n//     },\n//     debug: false\n// }\n//\n// export default (req, res) => NextAuth(req, res, options)","map":{"version":3,"sources":["/home/luketfake/Documentos/Projects/nextjs-material-kit-master/src/pages/api/auth/[...nextauth].js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// import NextAuth from 'next-auth'\n// import Providers from 'next-auth/providers'\n// import url from \"url\";\n//\n// // let cachedDb: Db = null\n//\n// const connectToDatabase = async (uri) => {\n//     if (cachedDb) {\n//         return cachedDb\n//     }\n//\n//     const client = await MongoClient.connect(uri, {\n//         useNewUrlParser: true,\n//         useUnifiedTopology: true\n//     })\n//\n//     const dbName = url.parse(uri).pathname.substr(1)\n//\n//     const db = client.db(dbName)\n//\n//     // cachedDb = db\n//\n//     return db\n// };\n//\n// const options = {\n//     providers: [\n//         Providers.GitHub({\n//             clientId: process.env.GITHUB_ID,\n//             clientSecret: process.env.GITHUB_SECRET\n//         }),\n//         Providers.Credentials({\n//             name: 'Credentials',\n//             credentials: {\n//                 email: { label: 'email', type: 'email', placeholder: 'E-mail' },\n//                 password: { label: 'password', type: 'password' }\n//             },\n//             async authorize(credentails) {\n//                 const db = await connectToDatabase(process.env.MONGODB_URI);\n//\n//                 const collection = db.collection('users');\n//\n//                 const user = await collection.findOne({ email: credentails.email })\n//\n//                 if ((!user) || (!await bcrypt.compare(credentails.password, user.password))) {\n//                     return Promise.reject('/');\n//                 }\n//\n//                 user.password = undefined;\n//\n//                 return Promise.resolve(user)\n//             },\n//         })\n//     ],\n//     database: process.env.MONGODB_URI,\n//     session: {\n//         jwt: true\n//     },\n//     jwt: { },\n//     pages: {\n//         signIn: '/auth/signin',\n//         signOut: '/auth/signout',\n//         error: '/auth/error',\n//         verifyRequest: '/auth/verify-request',\n//         newUser: null\n//     },\n//     callbacks: {\n//         signIn: async (user, account, profile) => {\n//             const isAllowedToSignIn = true\n//\n//             if (isAllowedToSignIn) {\n//                 return Promise.resolve(true)\n//             }\n//\n//             return Promise.resolve(false)\n//         },\n//         redirect: async (url, baseUrl) => {\n//             return url.startsWith(baseUrl)\n//                 ? Promise.resolve(url)\n//                 : Promise.resolve(baseUrl)\n//         },\n//         session: async (session, user, sessionToken) => {\n//             session.foo = 'bar' // Add property to session\n//             return Promise.resolve(session)\n//         }\n//     },\n//     events: {\n//         signIn: async (user, account, profile) => {\n//             console.log('LogedIn')\n//             return Promise.resolve('/home')\n//         },\n//         signOut: async (message) => { console.log('console2', message) },\n//         createUser: async (message) => { console.log('console3', message) },\n//         redirect: async (url, baseUrl) => { return Promise.resolve(baseUrl) },\n//         session: async (session, user) => { return Promise.resolve(session) },\n//         error: async (message) => { console.log('console6', message)  }\n//     },\n//     debug: false\n// }\n//\n// export default (req, res) => NextAuth(req, res, options)\n"]},"metadata":{},"sourceType":"script"}